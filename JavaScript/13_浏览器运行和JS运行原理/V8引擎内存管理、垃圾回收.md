内存管理
- JavaScript的内存管理是自动的
- 关于原始数据类型 直接在栈内存中分配
- 关于复杂数据类型 在堆内存中分配

垃圾回收(GC)

- 因为内存大小是有限的 所以在内存不需要的时候 需要进行释放 用于腾出空间
- GC对于内存管理有着对应的算法
- 常见的算法
  - 引用计数(Reference Count) 
    - 当一个对象有引用指向它时 对应的引用计数+1 
    - 当没有对象指向它时 则为0 此时进行回收
    - 但是有一个严重的问题 - 会产生循环引用
  - 标记清除(Mark-Sweep)
    - 核心思路: 可达性
    - 有一个根对象 从该对象出发 开始引用到所用到的对象 对于根对象没有引用到的对象 认为是不可用的对象
    - 对于不可用的对象 则进行回收
    - 该算法有效的解决了循环引用的问题
    - 目前V8引擎采用的就是该算法
- V8引擎为了优化 在采用标记清除的过程中也引用了其他的算法
  - 标记整理
    - 和标记清除相似 不同的是回收时 会将保留下来的存储对象整合到连续的内存空间 避免内存碎片化
  - 分代收集(Generational Collection)
    - 将内存中的对象分为两组 新的空间 旧的空间
    - 对于长期存活的对象 会将该对象从新空间移到旧空间中 同时GC检查次数减少
    - 将新空间分为from和to 对象的GC查找之后从from移动到to空间中 然后to变为from from变为to 循环几次 对于依然存在的对象 移动到旧空间中
  - 增量收集(Increment Collection)
    - 如果存在许多对象 则GC试图一次性遍历所有的对象 可能会对性能造成一定的影响 
    - 所以引擎试图将垃圾收集工作分成几部分 然后这几部分逐一处理 这样会造成微小的延迟 而不是很大的延迟
  - 闲时收集(IdIe-time Collection)
    - GC只会在CPU空闲的时候运行 减少可能对代码执行造成的影响